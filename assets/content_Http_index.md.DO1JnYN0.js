import{_ as e,c as d,o as t,a2 as o}from"./chunks/framework.DwDoyBw8.js";const u=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"content/Http/index.md","filePath":"content/Http/index.md"}'),c={name:"content/Http/index.md"},l=o('<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><h2 id="http的特点和缺点" tabindex="-1">HTTP的特点和缺点 <a class="header-anchor" href="#http的特点和缺点" aria-label="Permalink to &quot;HTTP的特点和缺点&quot;">​</a></h2><p>特点：<code>无连接</code>、<code>无状态</code>、<code>灵活</code>、<code>简单快速</code></p><ul><li>无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接</li><li>无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销，这是优点也是缺点</li><li>灵活：通过http协议中头部的 Content-Type 标记， 可以传输任意数据类型的数据对象（文本、图片、视频等），非常灵活</li><li>简单快速：发送请求访问某个资源时，只需传送请求方法和URL就可以来，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快</li></ul><p>缺点：<code>无状态</code>、<code>不安全</code>、<code>明文传输</code>、<code>对头阻塞</code></p><ul><li>无状态：请求不会记录任何链接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次链接传送的数据量增大</li><li>不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改</li><li>明文传输：报文（header部分）使用的是明文，直接将信息暴露给了外界，wifi陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你 敏感信息</li><li>对头阻塞：开启长链接时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态。</li></ul><h2 id="http-报文组成部分" tabindex="-1">HTTP 报文组成部分 <a class="header-anchor" href="#http-报文组成部分" aria-label="Permalink to &quot;HTTP 报文组成部分&quot;">​</a></h2><p>http报文：由 <code>请求报文</code> 和 <code>响应报文</code> 组成</p><p>请求报文：由 <code>请求行</code>、<code>请求头</code>、<code>空行</code>、<code>请求体</code> 四部分组成</p><p>响应报文：由 <code>状态行</code>、<code>响应头</code>、<code>空行</code>、<code>响应体</code> 四部分组成</p><ul><li>请求行：包含http方法，请求地址， http协议以及版本</li><li>请求头/响应头：就是一些key：value来告诉服务端我要哪些内容，要注意什么类型等，<a href="https://kb.cnblogs.com/page/92320/" target="_blank" rel="noreferrer">请求头/响应头每一个字段详解</a></li><li>空行：用来区分首部和实体，因为请求头都是key：value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当做请求体来解析了。</li><li>请求体：请求的参数</li><li>响应体：服务端返回的数据</li></ul><h2 id="http-请求方法-9种" tabindex="-1">HTTP 请求方法 (9种) <a class="header-anchor" href="#http-请求方法-9种" aria-label="Permalink to &quot;HTTP 请求方法 (9种)&quot;">​</a></h2><p>HTTP1.0： <code>GET</code>、<code>POST</code>、<code>HEAD</code></p><p>HTTP1.1：<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></p><p>| 方法 | 描述 | | --- |: --- 😐 | GET | 获取资源 | | POST | 传输资源，通常会造成服务器资源的修改 | | HEAD | 获得报文首部 | | PUT | 更新资源 | | PATCH | 对PUT的补充，对已知资源部分更新 | | DELETE | 删除资源 | | OPTIONS | 列出请求资源支持的请求方法，用来跨域请求 | | TRACE | 追踪请求/响应路径，用于测试或诊断 | | CONNECT | 将连接改为管道方式用于代理服务器(隧道代理) |</p><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别&quot;">​</a></h2><ul><li><code>GET</code> 在浏览器回退时是无害的，而 <code>POST</code> 会再次发起请求</li><li><code>GET</code> 请求会被浏览器主动缓存，而 <code>POST</code> 不会，除非手动设置</li><li><code>GET</code> 请求参数挥着保留在浏览器历史记录里， 而 <code>POST</code> 中的参数不会被保留</li><li><code>GET</code> 请求在 <code>URL</code> 中传递的参数有长度限制（浏览器限制大小不同），而 <code>POST</code> 没有限制</li><li><code>GET</code> 参数通过 <code>URL</code> 传递, <code>POST</code> 放在 <code>Request body</code> 中</li><li><code>GET</code> 产生的URL地址可以被收藏，而 <code>POST</code> 不可以</li><li><code>GET</code> 没有 <code>POST</code> 安全，因为 <code>GET</code> 请求参数直接暴露在 <code>URL</code> 上， 所以不能用来传递敏感信息</li><li><code>GET</code> 请求只能进行 <code>URL</code> 编码， 而 <code>POST</code> 支持多种编码方式</li><li>对参数的数据类型， <code>GET</code> 只接受 <code>ASCII</code> 字符，而 <code>POST</code> 没有限制</li><li><code>GET</code> 产生一个 TCP 数据包，<code>POST</code> 产生两个数据包（Firefox只发一次）。GET 浏览器把 http header 和 data 一起发出去，响应成功200，POST先发送 header，响应100 continue, 再发送data，响应成功200</li></ul><h2 id="常见-http-状态码" tabindex="-1">常见 HTTP 状态码 <a class="header-anchor" href="#常见-http-状态码" aria-label="Permalink to &quot;常见 HTTP 状态码&quot;">​</a></h2><p>1xx：提示信息————表示请求已接收，继续处理</p><p>2xx：成功————表示请求已被成功接收</p><p>3xx：重定向————表示要完成请求必须进行进一步操作</p><p>4xx：客户端错误————表示请求有语法错误或请求无法实现</p><p>5xx：服务端错误————表示服务器未能实现合法的请求</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>请求成功</td></tr><tr><td>206</td><td>已完成指定范围的请求，场景如video，audio播放文件较大，文件分片时</td></tr><tr><td>301</td><td>永久重定向</td></tr><tr><td>302</td><td>临时重定向</td></tr><tr><td>304</td><td>请求资源未修改，可以使用缓存的资源，不用在服务器取</td></tr><tr><td>400</td><td>请求有语法错误</td></tr><tr><td>401</td><td>没有权限访问</td></tr><tr><td>403</td><td>服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时</td></tr><tr><td>404</td><td>请求资源不存在</td></tr><tr><td>500</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>503</td><td>请求未完成，因服务器过载，死机或维护等</td></tr></tbody></table><h2 id="http-和-https-的区别" tabindex="-1">HTTP 和 HTTPS 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;HTTP  和 HTTPS 的区别&quot;">​</a></h2><ul><li>HTTP 是 <code>明文传输</code>，不安全的， HTTPS 是 <code>加密传输</code>, 安全的多</li><li>HTTP 标准端口是 <code>80</code>, HTTPS 标准端口是 <code>443</code></li><li>HTTP 不用认证证书 <code>免费</code>, HTTPS 需要认证证书 <code>要钱</code></li><li><code>连接方式不同</code>， HTTP 三次握手， HTTPS中TLS1.2版本7次，TLS1.3版本6次</li><li>HTTP 在 OSI 网络模型中是在 <code>应用层</code>, 而 HTTPS 的TLS是在 <code>传输层</code></li><li>HTTP 是 <code>无状态</code> 的, HTTPS 是 <code>有状态</code> 的</li></ul><h2 id="https优缺点" tabindex="-1">HTTPS优缺点 <a class="header-anchor" href="#https优缺点" aria-label="Permalink to &quot;HTTPS优缺点&quot;">​</a></h2><p>优点:</p><ul><li>内容加密，中间无法查看原始内容</li><li>身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持</li><li>数据完整性，防止内容被第三方冒充或篡改</li><li>虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本</li></ul><p>缺点：</p><ul><li>要钱，功能越强大的证书费用越贵</li><li>证书需要绑定IP，不能在同一个IP上绑定多个域名</li><li>https双方加解密，耗费更多服务器资源</li><li>https 握手更耗时，降低一定用户访问速度（优化好就不是缺点了）</li></ul>',31),i=[l];function a(T,r,h,p,P,n){return t(),d("div",null,i)}const H=e(c,[["render",a]]);export{u as __pageData,H as default};
